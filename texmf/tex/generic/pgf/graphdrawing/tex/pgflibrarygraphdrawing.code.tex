% Copyright 2010 by RenÃ©e Ahrens, Olof Frahm, Jens Kluttig, Matthias Schulz, Stephan Schuster
% Copyright 2011 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS[v\pgfversion] $Header: /cvsroot/pgf/pgf/generic/pgf/graphdrawing/tex/pgflibrarygraphdrawing.code.tex,v 1.22 2012/09/27 11:45:22 tantau Exp $



% check if luatex is running

\ifx\directlua\relax%
  \PackageError{pgf}{You need to run LuaTeX to use the graph drawing library}{}
  \expandafter\endinput
\fi
\ifx\directlua\undefined%
  \PackageError{pgf}{You need to run LuaTeX to use the graph drawing library}{}
  \expandafter\endinput
\fi



%
% This file defines the basic interactions between LUA and PGF
%

%
% This box is used for passing pgf elements to lua and vice versa 
%
% After the invocation of \pgfpositionnodelater the caller should copy the contents of 
% \box\pgfpositionnodelaterbox to another box register (for this refer to the manual).
%


% 
% Initialize the lua graph drawing environment
%
\directlua{ require 'pgf.gd.control.TeXInterface' } % Load the main communication class


%
% Basic Interface to the Graph Drawing Engine
%

% 
% In order to use the graph drawing engine, inside a pgfpicture you
% need to create a graph drawing scope using the following commands;
%



% 
% All graph drawing keys normally live in the following namespace:
% /graph drawing. 
%

\def\pgfgdset{\pgfqkeys{/graph drawing}}




% 
% Requests
% 
% Description:
% 
% This key is used to ``request'' a graph drawing scope and a
% layout. The objective of this key is to make it easier for users and
% algorithm designers to control the slightly involved
% back-and-forth-calling between the different layers.
% 
% This key does the following: When called inside a pgfpicture
% (otherwise, the call is "illegal"), it will call a call-back with
% two parameters. This callback will get passed some code that should
% be executed at the beginning of ``the next scope'' and some code
% that should be executed at the end of that scope.
% 
% The code passed to the callbacks will have a different effect,
% depending on whether we are currently inside a layout scope or not
% (if no graph drawing scope is open, we are 
% not inside a layout). If we are not inside a layout scope (or if the
% layout scope has been interrupted), the code will issue a
% \pgfgdbeginscope command in the opening code and a corresponding
% scope ending command in the closing code. Next, the two code pieces
% always contain \pgfgdbeginlayout and \pgfgdendlayout.
% 
%
% The main use of this key is at the end of a layout style. The idea
% is that a typical style like, say, "tree layout" can be defined like
% this:
% 
% binary tree layout/.style={
%   algorithm=pgf.gd.trees.ReingoldTilford1981,
%   minimum number of children=2,
%   significant sep=1em,
%   request scope and layout
% }
%
% Note that the "request scope and layout" key will not immediately
% trigger a layout scope to be created; rather, the TikZ callback will
% call it only at the beginning of the scope, which will be after
% other options in the current list of options have been parsed. So,
% when you write \graph [binary tree layout, significant sep=2em] ...,
% the "significant sep" option has an effect despite being given
% *after* the "request scope and layout" key since the actual opening
% of the scope happens only before the "..." part is parsed.

\pgfgdset{request scope and layout/.code=\pgfgd@requestcallback{\pgfgdbeginrequest}{\pgfgdendrequest}}

\def\pgfgd@requestcallback#1#2{%
  #1\def\pgf@gd@after@request{#2\egroup}\bgroup\aftergroup\pgf@gd@after@request%
} % Default for basic layer

\def\pgfgdbeginrequest{%
  \ifpgfgdlayoutscopeactive%
  \else%
    \expandafter\pgfgdbeginscope%
  \fi%
      \pgfgdbeginlayout%  
}
\def\pgfgdendrequest{%
      \pgfgdendlayout%
  \ifpgfgdlayoutscopeactive%
  \else%
    \expandafter\pgfgdendscope%
  \fi%  
}
\newif\ifpgfgdlayoutscopeactive


% Set the request callback
% 
% #1 = A macro
% 
% Description:
% 
% Sets the request callback as described in the "request scope and
% layout" key.

\def\pgfgdsetrequestcallback#1{\let\pgfgd@requestcallback#1}




%
% An if that is true exactly if we are inside a graph drawing scope
%

\newif\ifpgfgdgraphdrawingscopeactive


% Begins a new graph drawing scope
% 
% Description:
%
% Inside a graph drawing scope, all pgf nodes that are newly created
% are automatically passed to the graph drawing engine. In contrast,
% edges have to be indicated explicitly using the macro \pgfgdedge
% (this is because it is somewhat unclear what, exactly, should count
% as an edge). Naturally, users typically will not call \pgfgdedge
% explicitly, but have styles and keys invoke it internally.
%
% Usage:
% 
% \pgfgdset{algorithm=somealgorithm}
% \pgfgdbeginscope
%   \pgfnode{rectangle}{center}{A}{A}{}
%   \pgfnode{rectangle}{center}{B}{B}{}
%   \pgfnode{rectangle}{center}{C}{C}{}
%   \pgfgdedge{A}{B}{->}{}{}
%   \pgfgdedge{B}{C}{->}{}{}
%   \pgfgdedge{C}{A}{->}{}{}
% \pgfgdendscope
% 
% Naturally, users will typically use TikZ's somewhat simpler syntax: 
% 
% \tikz \graph [some algorithm] { A -> B -> C -> A };

\def\pgfgdbeginscope{%
  \begingroup % Protecting scope
    % get options
    \pgfkeysgetvalue{/graph drawing/graph parameters}\pgf@gd@graph@parameters%
    \directlua{
      pgf.gd.control.TeXInterface.beginGraphDrawingScope({\pgf@gd@graph@parameters})
    }%
    \begingroup % Inner scope, the actual nodes will be inserted after
                % this scope has been closed
      % Indicate that we are now inside a graph drawing scope
      \pgfgdgraphdrawingscopeactivetrue
      % Switch on late positioning
      \pgfpositionnodelater{\pgf@gd@positionnode@callback}
      % Switch on late edges
      \pgfgd@latecallback%
      % Kill transformations (will be added by the position now
      % macros)
      \pgftransformreset
}


% Ends a graph drawing scope
% 
% Description:
%
% This macro invokes the selected graph drawing algorithm and
% ships out all nodes within this scope
%
% See \pgfgdbeginscope

\def\pgfgdendscope{%
      \directlua{
        pgf.gd.control.TeXInterface.createGraphDrawingCoroutine()
        pgf.gd.control.TeXInterface.resumeGraphDrawingCoroutine()
      }
      \endgroup
    % Late positioning has ended
    \directlua{pgf.gd.control.TeXInterface.endGraphDrawingScope()}
  \endgroup
}







% Hook into graph specification
% 
% #1 = code
% 
% Description:
% 
% Allows you to specify code that should be active while the graph
% drawing engine collects the information concerning the graph, but
% which should no longer be active when the graph is rendered.

\def\pgfgdaddspecificationhook#1{
  \expandafter\def\expandafter\pgfgd@latecallback\expandafter{\pgfgd@latecallback#1}
}
\let\pgfgd@latecallback\pgfutil@empty



% Passing options to the graph drawing engine.
% 
% #1 = option's name
% #2 = option's value
% 
% Description:
%
% When a graph drawing algorithm starts working, a set of options,
% called "graph drawing parameters" in the following, can influence the
% way the algorithm works. For instance, an graph drawing parameter
% might be the average distance between vertices which the algorithm
% should take into account. Another example might be the fact the
% certain nodes are special nodes and that a certain edge should have
% a large label.
%
% These graph drawing parameters are different from "usual" pgf
% options: An alogrithmic parameter influenced the way the algorithm
% works, while usual options normally only influence how the result
% looks like. For instance, the fact that a node is red is not an
% graph drawing parameter (usually, at least), while the shape of a node
% might be an graph drawing parameter.
%
% There are three kinds of graph drawing parameters:
%
% 1) graph drawing graph parameters 
%    These parameters influence "the whole graph". An example
%    is the distance between vertices on the same level of a tree. 
%
% 2) graph drawing node parameters
%    These parameters are "attached" to a single node. This includes
%    options that are only meaningful in the context of a graph
%    drawing algorithm (like, say, the "mass" of a node in a
%    force-base algorith), but also hybrid attributed like the shape
%    of a node. The shape is important for pgf when it typesets the
%    node, but it may also be important for the graph drawing
%    algorithm since it might position circles differently from, say,
%    rectangles.
%    
% 3) graph drawing edge parameters
%    Similarly to nodes, edges can also have graph drawing
%    parameters. Also similarly to nodes, there can be purely
%    graph drawing parameters and also options that are hybrid.
%    
% You have to "declare" a graph drawing parameter similarly to a normal
% key, but instead of using the /.code, you use /.graph
% parameter, /.node parameter, and /.edge
% parameter. More details on how these handlers work is given below.
%
% Specifying the set of graph drawing parameters for a given graph or
% node or edge works as follows: When the graph drawing engine is
% started for a graph (using \pgfgdbeginscope), a snapshot is taken of
% all graph drawing graph parameters currently setup at this
% point. Similarly, when a node is created inside such a scope, a
% snapshot is taken of the set of all graph drawing node parameters in
% force at this point is taken and stored together with the
% node. Finally, when an edge is created, a snapshot of the setting of
% the graph drawing edge parameters is taken.
% 
% All of these option sets can easily be accessed inside the graph 
% drawing algorithms, see the documentation of the lua layer.

\def\pgfgdgraphparameter#1#2{%
  \pgfkeysaddvalue{/graph drawing/graph parameters}{}{{key='\luaescapestring{#1}',value=#2},}%
}
\def\pgfgdnodeparameter#1#2{%
  \pgfkeysaddvalue{/graph drawing/node parameters}{}{{key='\luaescapestring{#1}',value=#2},}%
}
\def\pgfgdedgeparameter#1#2{%
  \pgfkeysaddvalue{/graph drawing/edge parameters}{}{{key='\luaescapestring{#1}',value=#2},}%
}

\pgfgdset{
  graph parameters/.initial=,
  node parameters/.initial=,
  layout node parameters/.initial=,
  edge parameters/.initial=,
}  



% Passing hybrid options
% 
% #1 = option's name
% #2 = option's value
% 
% Description:
%
% Some options, like "sibling distance", can both be considered as
% node options, but also as graph options, in which case they are
% supposed to apply to all nodes of the graph. Such options could, in
% principle, be passed to all nodes, but it much more economic to have
% them defined only once for the whole graph and, then, only store
% deviating values at special nodes.
%
% To facilitate this, you can declare that an option as a hybrid
% node/graph parameter or as a hybrif edge/graph parameter. For such
% parameters, the following happens: Whenever you set the parameter
% outside a graph drawing scope, it will be considered as a graph
% parameter, when you set it inside a graph drawing scope, it will be
% set as a node/edge parameter. This means that when you write, for
% instance, \graph [layered layout, sibling distance=1cm] 
% { a [sibling distance=2cm] -- b -- c }, the first "sibling distance"
% is a graph parameter (the graph drawing scope triggered by "layered
% layout" starts only after all options have been parsed), while the
% second "sibling distance" applies only to node "a".


\def\pgfgdhybridnodegraphparameter#1#2{%
  \ifpgfgdgraphdrawingscopeactive%
    \pgfgdnodeparameter{#1}{#2}%
  \else%
    \pgfgdgraphparameter{#1}{#2}%
  \fi%
}
\def\pgfgdhybridedgegraphparameter#1#2{%
  \ifpgfgdgraphdrawingscopeactive%
    \pgfgdedgeparameter{#1}{#2}%
  \else%
    \pgfgdgraphparameter{#1}{#2}%
  \fi%
}



% Key handler /.graph parameter
% 
% Description:
%
% When this key hanlder is applied to a key, this key becomes a graph
% drawing graph parameter (as explained above). Subsequently, setting
% this key will cause special internals to be setup so that graph
% drawing algorithms can access the value of this key easily and
% directly inside the lua layer.
% 
% A typical usage would be
%
%   /some path/my key/.graph parameter
%  
% Now, when people write /some path/my key=foo in their code, inside
% the algorithm the parameter "my key" would be set to "foo".
% 

\pgfkeys{
  /handlers/.graph parameter/.code=\pgf@gd@parameter{#1}{\pgfgdgraphparameter},
  /handlers/.node parameter/.code=\pgf@gd@parameter{#1}{\pgfgdnodeparameter},
  /handlers/.edge parameter/.code=\pgf@gd@parameter{#1}{\pgfgdedgeparameter},
  /handlers/.node or graph parameter/.code=\pgf@gd@parameter{#1}{\pgfgdhybridnodegraphparameter},
  /handlers/.edge or graph parameter/.code=\pgf@gd@parameter{#1}{\pgfgdhybridedgegraphparameter},
}
\def\pgf@gd@parameter#1#2{%
  \def\pgfgd@temp{#1}%
  \ifx\pgfgd@temp\pgfkeysnovalue@text\PackageError{pgf}{You must specify a parameter type for \pgfkeyscurrentpath}{}\fi%
  \edef\pgf@marshal{\noexpand\pgf@gd@@parameter{\pgfkeyscurrentpath}{\pgfgd@temp}{\noexpand#2}}
  \pgf@marshal%
}

\def\pgf@gd@@parameter#1#2#3{%
  \pgfkeysdef{#1}{
    \pgfkeys{/graph drawing/conversions/#2={##1}}%
    \expandafter\pgf@gd@@@parameter\expandafter{\pgfgdresult}{#3}{#1}%
  }%
}
\def\pgf@gd@@@parameter#1#2#3{#2{#3}{#1}}


% Key handler /.accumulates
% 
% When this handler is used with a key, it tells the engine that the
% parameter is "accumulating". This means that when the key is set
% several times, new values do not overwrite previous values. Rather,
% they are added to a table storing all values given to this key in
% the previous usages.

\pgfkeys{
  /handlers/.accumulates/.code=\directlua{pgf.gd.control.TeXInterface.setParameterAccumulates('\luaescapestring{\pgfkeyscurrentpath}')}
}



% Key handler /.parameter initial
%
% #1 = an initial value
%
% Description:
%
% Use this key handler instead of /.initial to assign an initial value
% to a graph parameter. What will happen is that on the Lua layer, the passed
% value is stored in a special table. Whenever the key is not
% explicitly set by the user, the value #1 will be used.
% 
% Note that
% 
%   /foo/.graph parameter, /foo=5
% 
% and
% 
%   /foo/.graph parameter, /foo/.parameter initial=5
%   
% have the same effect insofar as, in both cases, getOption ('/foo')
% will yield 5. The difference is that in the second case the TeX
% layer does not need to pass around huge lists of options and will,
% thus, be faster. In general, it is recommendable that initial values
% for graph drawing graph parameters are setup using this handler.
% 
% #1 is passed through the conversion of the key before being stored.

\pgfkeys{
  /handlers/.parameter initial/.code={
    {
      % Hack into setting of edge/node/graph parameters
      \let\pgfgdgraphparameter\pgf@gd@steal
      \let\pgfgdnodeparameter\pgf@gd@steal
      \let\pgfgdedgeparameter\pgf@gd@steal
      \expandafter\pgfkeys\expandafter{\pgfkeyscurrentpath={#1}}%
    }
  }
}

\def\pgf@gd@steal#1#2{%
  \directlua{pgf.gd.control.TeXInterface.setParameterDefault('\luaescapestring{#1}',#2)}%
}



% In many cases, when you specify a graph parameter, you will not wish
% the "actual" setting of the key to be passed to the algorithm. For
% instance, suppose we write 
% 
%   /some path/width/.graph parameter
% 
% Now we could write /some path/width=20pt+2pt, and inside the
% algorithm the parameter "width" would equal the string
% "20pt+2pt". However, inside the algorithm, it would be somewhat
% preferable to have access to the value "22" rather than the string
% "20pt+2pt". Similary, when the width is "1in", the algorithm will
% prefer to get passed the number "72.27" instead of "1in".
% 
% For this reason, when you define a graph drawing parameter, you can
% optionally specify a conversion that will be applied to the
% key's value before it is passed to the algorithm. To do so, 
% write
% 
% /some path/my key/.graph parameter=conversion key
% 
% The conversion key will be executed with path prefix /graph
% drawing/conversions/. It gets passed the value that was
% assigned to the parameter key. It should store the "result" of the
% conversion in the macro \pgfgdresult. The contents of this macro is
% the text that will actually be passed down to the algorithm.
% 
% As an example, let us start with the default conversion: It simply
% stores its parameter as the result:
% 
% /graph drawing/conversions/string/.code=\def\pgfgdresult{'\luaescapestring{#1}'}
% 
% A more complicated example is the math conversion:
% 
% /graph drawing/conversions/math/.code=
%    \pgfmathparse{#1}\let\pgfgdresult\pgfmathresult

\pgfgdset{
  conversions/string/.code=\def\pgfgdresult{'\luaescapestring{\detokenize{#1}}'},
  conversions/raw/.code=\def\pgfgdresult{#1},
  conversions/boolean/.code=\def\pgf@test{#1}\ifx\pgf@test\pgf@truetext\def\pgfgdresult{true}\else\def\pgfgdresult{false}\fi,
  conversions/number/.code=\pgfmathparse{#1}\let\pgfgdresult\pgfmathresult,
  conversions/number with optional and/.code={
    \pgfutil@in@{ and }{#1}%
    \ifpgfutil@in@%
      \pgf@gd@convert@and#1\pgf@stop%
    \else%
      \pgf@gd@convert@and#1 and #1\pgf@stop%
    \fi%
  },
  conversions/direction/.code=\pgf@lib@gd@grow@dir{#1}\let\pgfgdresult\pgfmathresult,
  conversions/coordinate/.code args={(#1pt,#2pt)}{\edef\pgfgdresult{{#1,#2}}},
  conversions/table with node keys/.code=\def\pgfgdresult{pgf.gd.control.TeXInterface.convertNameKeysToVertexKeys({#1})},
}
\def\pgf@truetext{true}

\def\pgf@gd@convert@and#1 and #2\pgf@stop{\pgfmathparse{#1}\let\pgfgdresult\pgfmathresult}

% Graph drawing graph parameter "algorithm"
%  
% Description:
% 
% Used to decide which algorithm is used in the graph drawing engine
% for drawing the next graph.

\pgfgdset{
  algorithm/.graph parameter=string
}





% Set options for an already existing node
% 
% #1 = node name
% 
% These node parameters of #1 will be updated with the current values
% of the node parameters. The node #1 must previously have been passed
% to the gd engine. If some of the options have already been set for
% the node, these settings will be overruled.

\def\pgfgdsetlatenodeoption#1{%
  {%
    \pgfkeysgetvalue{/graph drawing/node parameters}\pgf@gd@node@options%
    % call lua system library to create a lua node object
    \directlua{pgf.gd.control.TeXInterface.setLateNodeOptions(
        '\luaescapestring{#1}',
        {\pgf@gd@node@options}) }
  }%
}





% Adds an edge to the graph
%
% #1 = first node
% #2 = second node
% #3 = edge direction
% #4 = edge options (will be executed in a protected environment)
% #5 = aux stuff (curtesy for TikZ -- edge nodes)
%
% Description:
%
% Creating an edge means that you tell the graph drawing algorithm
% that #1 and #2 are connected. The "kind" of connection is indicated
% by #3, which may be one of the following:
% 
% ->  = a directed edge (also known as an arc) from #1 to #2
% --  = an undirected edge between #1 and #2
% <-  = a directed edge from #2 to #1, but with the "additional hint"
%       that this is a "backward" edge. A graph drawing algorithm may
%       or may not take this hint into account
% <-> = a bi-directed edge between #1 and #2.
% 
%
% The parameters #4 and #5 are a bit more tricky. When an edge between
% two vertices of a graph is created via \pgfgdedge, nothing is
% actually done immediately. After all, without knowing the final
% positions of the nodes #1 and #2, there is no way of
% creating the actual drawing commands for the edge. Thus, the actual
% drawing of the edge is done only when the graph drawing algorithm is
% done (namely in the macro \pgfgdedgecallback, see later).
% 
% Because of this "delayed" drawing of edges, options that influence
% the edge must be retained until the moment when the edge is actually
% drawn. Parameters #4 and #5 store such options.
% 
% Let us start with #4. This parameter should be set to a list of
% key-value pairs like
% 
%   /tikz/.cd, color=red, very thick, this edge must be vertical
% 
% Some of these options may be of interest to the graph drawing
% algorithm (like the last option) while others will 
% only be important during the drawing of edge (like the first
% option). The options that are important for the graph drawing
% algorithm must be passed to the algorithm via setting keys that have
% been declared using the handler .edge parameter (see 
% above).
% 
% The tricky part is that options that are of interest to the graph
% drawing algorithm must be executed *before* the algorithm starts,
% but the options as a whole are usually only executed during the
% drawing of the edges, which is *after* the algorithm has finished.
% 
% To overcome this problem, the following happens:
% 
% The options in #4 are executed "tentatively" inside
% \pgfgdedge. However, this execution is done in a "heavily guarded
% sandbox" where all effects of the options (like changing the
% color or the line width) do not propagate beyond the sandbox. Only
% the changes of the graph drawing edge parameters leave the
% sandbox. These parameters are then passed down to the graph drawing
% engine.
% 
% Later, when the edge is drawn using \pgfgdedgecallback, the options #4
% are available once more and then they are executed normally.
%
% Note that when the options in #4 are executed, no path is
% preset. Thus, you typically need to start it with, say, /tikz/.cd.
%
%
% The text in #5 is some "auxilliary" text that is simply stored away
% and later directly to \pgfgdedgecallback. This is a curtesy to TikZ,
% which can use it to store its node labels. 
%
% Example:
%
% \pgfgdedge{A}{B}{->}{red}{}
%
\def\pgfgdedge#1#2#3#4#5{%
  % Ok, setup sandbox
  \begingroup%
    \setbox0=\hbox{{%
        \pgfinterruptpath%
          \pgfgdprepareedge%
          \pgfkeys{#4}%
          \pgfkeysgetvalue{/graph drawing/edge parameters}\pgf@gd@edge@options%
          % create edge in Lua
          \toks0={#4}%
          \toks1={#5}%
          \directlua{
            pgf.gd.control.TeXInterface.addPgfEdge(
            '\luaescapestring{#1}','\luaescapestring{#2}','\luaescapestring{#3}',
            {\pgf@gd@edge@options},
            '\luaescapestring{\the\toks0}','\luaescapestring{\the\toks1}')
          }%
        \endpgfinterruptpath%
      }}%
  \endgroup%
}

\let\pgfgdprepareedge=\pgfutil@empty
\def\pgfgdaddprepareedgehook#1{\expandafter\def\expandafter\pgfgdprepareedge\expandafter{\pgfgdprepareedge#1}}


% Callbacks: Called before the shipout of nodes and edges starts
%
% First, the general begin shipout is called. Then, the node shipout
% starts, the nodes are created, and then the end of the node shipout
% is signaled. Next, the edge shipout starts and ends. Finally, the
% end shipout is called.

\def\pgfgdbeginshipout{%
  \pgfscope%
    \catcode`\@=11\relax%
}
\def\pgfgdendshipout{%
    \box\pgf@gd@prekind@box%
    \ifpgf@gd@edges@behind@nodes%
      \box\pgf@gd@edge@box%
      \box\pgf@gd@node@box%
    \else%
      \box\pgf@gd@node@box%
      \box\pgf@gd@edge@box%
    \fi%
    \box\pgf@gd@postkind@box%
  \endpgfscope
}

\newbox\pgf@gd@node@box
\newbox\pgf@gd@edge@box
\newbox\pgf@gd@prekind@box
\newbox\pgf@gd@postkind@box
\def\pgfgdbeginnodeshipout{%
  \setbox\pgf@gd@node@box=\hbox\bgroup%
}
\def\pgfgdendnodeshipout{%
  \egroup%
}

\def\pgfgdbeginedgeshipout{%
  \setbox\pgf@gd@edge@box=\hbox\bgroup%
}

\def\pgfgdendedgeshipout{%
  \egroup
}

\def\pgfgdbeginprekindshipout{%
  \setbox\pgf@gd@prekind@box=\hbox\bgroup%
}

\def\pgfgdendprekindshipout{%
  \egroup
}

\def\pgfgdbeginpostkindshipout{%
  \setbox\pgf@gd@postkind@box=\hbox\bgroup%
}

\def\pgfgdendpostkindshipout{%
  \egroup
}

\newif\ifpgf@gd@edges@behind@nodes
\pgf@gd@edges@behind@nodestrue



% Define a callback for rendering edges
%
% #1 = macro name
% 
% Descriptions:
% 
% This is a callback from the graph drawing engine. At the end of the
% creation of a graph, when the nodes have been positioned, this macro
% is called once for each edge. The macro should take the following
% parameters:
% 
% #1 = from node
% #2 = to node
% #3 = direction (<-, --, ->, or <->)
% #4 = original options
% #5 = aux text (typically edge nodes)
% #6 = algorithm-generated options
% #7 = bend information
%
% The first five parameters are the original values that were passed
% down to the \pgfgdedge command.
% 
% #6 contains options that have been "computed by the algorithm". For
% instance, an algorithm might have determined, say, flow capacities
% for edges and it might now wish to communicate this information back
% to the upper layers. These options should be executed with the path
% /graph drawing.
% 
% #7 contains algorithmically-computed information concerning how the
% edge should bend. Currently, this will be a text like
% "--(10pt,20pt)--(30pt,40pt)" in tikz-syntax, but this may change to
% make things more portable.
% 
% By default, a simple line is drawn between the nodes. Usually, you
% will wish to install a more "fancy" callback, here.

\def\pgfgdsetedgecallback#1{\let\pgfgdedgecallback=#1}

\def\pgfgddefaultedgecallback#1#2#3#4#5#6#7{%
  {%
    \pgfscope
      \pgfpathmoveto{\pgfpointshapeborder{#1}{\pgfpointanchor{#2}{center}}}
      \pgfpathlineto{\pgfpointshapeborder{#2}{\pgfpointanchor{#1}{center}}}
      \pgfusepath{stroke}
    \endpgfscope
  }
}

\pgfgdsetedgecallback{\pgfgddefaultedgecallback}







% Helper keys for defining new graph drawing algorithms and their
% options  
% 
% Description:
% 
% When you hanve written a new graph drawing algorithm in lua (see the
% documentation for how this works), you need to make the higher
% levels aware of the algorithm and its parameters.
% 
% In principle, users could just write /graph drawing/algorithm=your
% algorithm's name and set options using for instance /graph
% drawing/your options=foo, but this would result in numerous
% repetitions of the prefix "/graph drawing/" in the code. Indeed, it
% would be somewhat preferable that users can just write things like
% 
% \tikz \graph [planar] { ... };
% 
% and have the option "planar" launch some fancy algorithm. However,
% "planar" will then have to have the path /tikz/graphs/planar, while
% the graph drawing algorithms expect their keys in  /graph drawing.
% 
% To overcome these difficulties, key forwarding is used. You declare
% you keys with the /graph drawing/ path, which is the "correct way"
% of declaring these keys, and then additionally setup keys in the
% /tikz/ and the /tikz/graphs/ paths that forward their values to the
% /graph drawing/ path. The helper functions below are intended to make
% this reasonably easy.
% 
%
% Graph parameters come in too flavours: "common" and
% "family-specific". A "common" graph parameter can be used by
% several graph drawing algorithms. An example are orientation keys,
% which can actually be applied to any graph in a postprocessing
% step. In contrast, "family-specific" keys are only important for
% one algorithm or only for algorithms from a small family of
% algorithms. For instance, a "stiffness" for spring layout algorithms
% would only apply to, well, spring layout algorithms.
% 
% The common graph parameters reside in the path /graph drawing/,
% while the family-specific graph parameters reside in the path /graph
% drawing/<family name>/. For common graph parameters, forwarding will
% be setup in paths like /tikz/ or /tikz/graphs, so you can use these
% keys directly. In contrast, no forwarding will be setup for
% family-specific keys. Rather, these keys can be passed to the
% algorithm's key, which will in turn executed the keys with the
% prefix /graph drawing/<family name>/.


% Declare keys for a new algorithm
% 
% #1 = algorithm's key name
% #2 = algorithm's family name
% #3 = options that configure the algorithm
% 
% Description:
% 
% This will setup the following keys:
% 
% /graph drawing/#1 is setup so that, when executed, the graph drawing
% algorithm is configured by the options in #3 and the value passed to
% are executed as keys with the path prefix /graph
% drawing/#2. This key does nothing by
% default, but it could be used to setup things (as is done in tikz)
% to start the graph drawing engine for the current scope.
% 
% Next, forwarding fill be setup for each path in the current
% forwarding list (set using \pgfgdsetkeyforwardinglist). If <path> is
% in this list, <path>/#1 is forwarded to /graph drawing/#1.
% 
% All keys in #4 are setup with the path prefix #2.
% 
% Note that when several algorithms share keys, they should share the
% family.
%
%
% Example:
%
% \pgfgddeclarealgorithmkey
% {AhrensFKSS2011 minimize crossings}
% {AhrensFKSS2011 minimize crossings}
% {algorithm=localsearchgraph}

\def\pgfgddeclarealgorithmkey#1#2#3{%
  \pgfkeys{
    /graph drawing/#1/.code=\pgfgdset{%
      #3,%
      #2/.cd,%
      ##1,%
      /graph drawing/request scope and layout%
    }
  }%
  \pgf@gd@setup@forwards{#1}
  \pgfutil@g@addto@macro\pgf@gd@forwards@list{\pgf@gd@setup@forwards{#1}}
}
\def\pgf@gd@setup@forwards#1{
  \let\pgf@temp\pgfutil@empty
  \foreach \pgf@gd@path in \pgf@gd@forwarding@list {
    \ifx\pgf@gd@path\pgfutil@empty\else%
      \expandafter\pgfutil@g@addto@macro\expandafter\pgf@temp\expandafter{\expandafter\pgfkeys\expandafter{\pgf@gd@path#1/.forward to=/graph drawing/#1}}
    \fi%
  }%
  \pgf@temp
}

\let\pgf@gd@forwards@list\pgfutil@empty




% Append to the forwarding list:
% 
% #1 = paths to append to the forwarding list
% 
% Description:
% 
% Append the paths in #1 (with trailing slashes) to the forwarding
% list.
% 
% If algorithms have already been declared, forwarding will also be
% setup for them (using a bit of magic...).

\def\pgfgdappendtoforwardinglist#1{%
  \let\pgf@gd@forwarding@list@orig\pgf@gd@forwarding@list
  \def\pgf@gd@forwarding@list{#1}%
  \pgf@gd@forwards@list%
  \expandafter\def\expandafter\pgf@gd@forwarding@list\expandafter{\pgf@gd@forwarding@list@orig,#1}
}
\let\pgf@gd@forwarding@list\pgfutil@empty



% Declare a new common key
% 
% #1 = an optional path prefix 
% #2 = a list of key declarations
% 
% Description:
% 
% Each <element> of #2 should have the form <key name>/<action>.
% This will cause the following to happen:
% 
% #1/<key name>/<action> is executed
% 
% If #1/<key name> was not defined before, for each <path> in the path
% list, a forward from <path>/<key name> to /graph drawing/<key name>
% is setup.
%
% Example:
%
% \pgfgddeclarekeys{/graph drawing}
% {
%   height/.graph parameter=number,
%   height/.parameter initial=5cm, % no forwarding since already defined.
%   width/.graph parameter=number,
%   width/.parameter initial=5cm,
% }

\def\pgfgddeclareforwardedkeys#1#2{%
  \def\pgf@gd@prefix{#1}%
  \let\pgf@temp\pgfutil@empty
  \foreach \pgf@gd@temp/\pgf@gd@dec in {#2} {%
    \ifx\pgf@gd@temp\pgfutil@empty\else%
    \pgfkeysifdefined{\pgf@gd@prefix/\pgf@gd@temp/.@def}{%
    \expandafter\expandafter\expandafter\def%
    \expandafter\expandafter\expandafter\content%
    \expandafter\expandafter\expandafter{%
    \expandafter\expandafter\expandafter\pgf@gd@parse@onlykey%
    \expandafter\expandafter\expandafter{\expandafter\pgf@gd@temp\expandafter}\expandafter{\pgf@gd@dec}}}{%
    \expandafter\expandafter\expandafter\def%
    \expandafter\expandafter\expandafter\content%
    \expandafter\expandafter\expandafter{%
    \expandafter\expandafter\expandafter\pgf@gd@parse@commonkey%
    \expandafter\expandafter\expandafter{\expandafter\pgf@gd@temp\expandafter}\expandafter{\pgf@gd@dec}}}%
    \expandafter\pgfutil@g@addto@macro\expandafter\pgf@temp\expandafter{\content}%
    \fi
  }
  \pgf@temp
}
\def\pgf@gd@parse@commonkey#1#2{%
  \pgfkeys{\pgf@gd@prefix/#1/#2}
  \pgf@gd@setup@forwards{#1}
  \pgfutil@g@addto@macro\pgf@gd@forwards@list{\pgf@gd@setup@forwards{#1}}
}
\def\pgf@gd@parse@onlykey#1#2{%
  \pgfkeys{\pgf@gd@prefix/#1/#2}
}



\pgfgddeclareforwardedkeys{/graph drawing}{
  nodes behind edges/.code=\pgf@gd@edges@behind@nodesfalse,
  edges behind nodes/.code=\pgf@gd@edges@behind@nodestrue
}







% 
% 
% 
% Anchoring 
% 
% (see Section~\ref{subsection-library-graphdrawing-anchoring})
% 
% 


% Anchors for an edge: An edge can have a tail and a head
% anchor. Ideally, the edge should start at the tail anchor of the
% tail node and end at the head anchor of the head node. A graph
% drawing algorithm may choose to ignore these settings.

\pgfgddeclareforwardedkeys{/graph drawing}{
  tail anchor/.edge parameter=string,
  head anchor/.edge parameter=string
}


% Desired positiong for a node
% 
% #1 = a coordinate
% 
% Description:
% 
% This node parameter stores a coordiante. When set, the layout
% algorithm is "requested" to try an place the node at 
% this position.

\pgfgddeclareforwardedkeys{/graph drawing}{
  desired at/.node parameter=coordinate
}




% Nudging a node
% 
% #1 = an offset (as a coordinate)
% 
% Description:
% 
% This node parameter allows you to slightly ``nudge'' (move) nodes
% after they have been positioned by the given offset. The idea is
% that this nudging is 
% done after the position of the node has been computed, so nudging
% has no influence on the actual graph drawing algorithms. This, in
% turn, means that you can use nudging to "correct" or "optimize" the
% positioning of nodes after the algorithm has computed something.

\pgfgddeclareforwardedkeys{/graph drawing}{
  nudge/.node parameter=coordinate
}


% Forcing a node
% 
% #1 = a coordinate
% 
% Description:
% 
% This node parameter allows you provide a position for a node to wish
% it will be forced after the graph algorithms have run. So, the node
% is positioned normally and the graph drawing algorithm does not know
% about the position #1. However, afterwards, the node is placed at #1
% regardless of what the algorithm has computed (all other nodes are
% unaffected). 

\pgfgddeclareforwardedkeys{/graph drawing}{
  regardless at/.node parameter=coordinate
}


% "Nail" a node to a position
% 
% #1 = a coordinate
% 
% Description:
% 
% This option combines "desired at" and "regardless at". Thus, the
% algorithm is "told" about the desired position. If it fails to place
% the node at the desired position, it will be put there
% regardless. The name of the key is intended to remind one of a node
% begin "nailed" to the canvas.

\pgfgddeclareforwardedkeys{/graph drawing}{
  nail at/.style={}
}
\pgfgdset{nail at/.style={%
    /graph drawing/desired at={#1},
    /graph drawing/regardless at={#1}
  }
}



% Default anchoring position
% 
% Description:
% 
% This node parameter stores two numbers in the format {#1}{#2}. A
% graph should be anchored at this position when there is no explict
% anchoring of any node.

\pgfgddeclareforwardedkeys{/graph drawing}{
  anchor at/.graph parameter=coordinate,
  anchor at/.parameter initial={(0pt,0pt)}
}


% Specify an anchor node
% 
% Description:
% 
% Requests that the graph is "anchored" at this node. If there are
% several, the first one is used. If there are none, the first node
% with a "desired at" is chosen. If there are none with that option
% either, the first node is used.

\pgfgddeclareforwardedkeys{/graph drawing}{
  anchor here/.node parameter=string,
  anchor here/.default=true,
  anchor node/.graph parameter=string,
}




% 
% 
% 
% Orientation
% 
% (see Section~\ref{subsection-library-graphdrawing-standard-orientation})
% 
% 


% The orient key
% 
% Description:
% 
% When used with an edge, the orient key specifies the desired slope of
% the edge:
% 
%   a --[orient=90] b  % Vertical edge, going up from a to b 
%  
% When used with a node, the syntax is :angle:anther_node, causing the
% graph to be oriented so that the line from the node to the other
% node has a slope of "angle"
% 
%   a[orient=:90:b] -- c -- b  % b will be above a.
%   
% The leading colon is optional, so orient=90:b is also fine.
%
% When used with a graph as a whole, the syntax is node1:angle:node2,
% with node1 being nonempty, causing the graph to be oriented so that
% the line from node1 to node2 has a slope of "angle"
% 
%  graph [orient=a:90:b] { a -- c -- b } % b will be above a.
%  
%  
% If a dash is found in the parameter, it will be replaced by :0:, so
% saying orient=a-b has the same effect as orient=a:0:b. A vertical
% bar is replaced by :-90:.

\pgfgddeclareforwardedkeys{/graph drawing}{orient/.code=,orient'/.code=}

\pgfkeys{/graph drawing/orient/.append code=\pgf@gd@orient@handle{#1}{orient}}
\pgfkeys{/graph drawing/orient'/.append code=\pgf@gd@orient@handle{#1}{orient'}}

\def\pgf@gd@orient@handle#1#2{
  \pgfutil@in@:{#1}%
  \ifpgfutil@in@%
    \pgf@lib@gd@parse@orient#1\pgf@stop{#2}%
  \else%
    \pgfutil@in@-{#1}%
    \ifpgfutil@in@%
      \pgf@lib@gd@parse@dash#1\pgf@stop{#2}%
    \else
      \pgfutil@in@|{#1}
      \ifpgfutil@in@%
        \pgf@lib@gd@parse@bar#1\pgf@stop{#2}%
      \else
        \expandafter\pgfutil@in@\pgf@lib@active@bar{#1}
        \ifpgfutil@in@%
          \pgf@lib@gd@parse@active@bar#1\pgf@stop{#2}%
        \else
          \pgf@lib@gd@grow@dir{#1}%
          \edef\pgf@marshal{\noexpand\pgfgdedgeparameter{/graph drawing/#2}{\pgfmathresult}}%
          \pgf@marshal%
        \fi%
      \fi%
    \fi%
  \fi%
}

\def\pgf@lib@gd@parse@dash#1-#2\pgf@stop#3{%
  \pgf@lib@gd@parse@orient#1:0:#2\pgf@stop{#3}%
}

\def\pgf@lib@gd@parse@bar#1|#2\pgf@stop#3{%
  \pgf@lib@gd@parse@orient#1:-90:#2\pgf@stop{#3}%
}

{
  \catcode`\|=13
  \gdef\pgf@lib@active@bar{|}
  \gdef\pgf@lib@gd@parse@active@bar#1|#2\pgf@stop#3{%
    \pgf@lib@gd@parse@orient#1:-90:#2\pgf@stop{#3}%
  }
}

\def\pgf@lib@gd@parse@orient#1:#2\pgf@stop#3{%
  \pgfutil@in@:{#2}%
  \ifpgfutil@in@%
    \pgf@lib@gd@parse@orient@final#1:#2\pgf@stop{#3}%
  \else%
    \pgf@lib@gd@parse@orient@final:#1:#2\pgf@stop{#3}%
  \fi%
}

\def\pgf@lib@gd@parse@orient@final#1:#2:#3\pgf@stop#4{%
  \pgf@lib@gd@grow@dir{#2}%
  \def\pgf@temp{#1}%
  \ifx\pgf@temp\pgfutil@empty
    \edef\pgf@marshal{\noexpand\pgfgdnodeparameter{/graph drawing/#4}{{\pgfmathresult,'\luaescapestring{#3}'}}}%
  \else%
    \edef\pgf@marshal{\noexpand\pgfgdgraphparameter{/graph drawing/#4}{{\pgfmathresult,'\luaescapestring{#1}','\luaescapestring{#3}'}}}%
  \fi%
  \pgf@marshal%
}


\def\pgf@lib@gd@grow@dir#1{%
  \ifcsname pgf@orient@direction@#1\endcsname%
    \expandafter\let\expandafter\pgfmathresult\csname pgf@orient@direction@#1\endcsname%
  \else
    \pgfmathparse{#1}%
  \fi
}

\def\pgf@orient@direction@down{-90}
\def\pgf@orient@direction@up{90}
\def\pgf@orient@direction@left{180}
\def\pgf@orient@direction@right{0}

\def\pgf@orient@direction@south{-90}
\def\pgf@orient@direction@north{90}
\def\pgf@orient@direction@west{180}
\def\pgf@orient@direction@east{0}

\expandafter\def\csname pgf@orient@direction@north east\endcsname{45}
\expandafter\def\csname pgf@orient@direction@north west\endcsname{135}
\expandafter\def\csname pgf@orient@direction@south east\endcsname{-45}
\expandafter\def\csname pgf@orient@direction@south west\endcsname{-135}



% The grow key
% 
% Description:
% 
% When specified with a node, causes the graph to be rotated such that
% the "growth" direction of the graph is the given angle (at least
% locally at the node).

\pgfgddeclareforwardedkeys{/graph drawing}{grow/.code=,grow'/.code=}

\pgfkeys{/graph drawing/grow/.append code=\pgf@gd@grow@handle{#1}{grow}}
\pgfkeys{/graph drawing/grow'/.append code=\pgf@gd@grow@handle{#1}{grow'}}

\def\pgf@gd@grow@handle#1#2{%
  \pgf@lib@gd@grow@dir{#1}%
  \edef\pgf@marshal{\noexpand\pgfgdhybridnodegraphparameter{/graph drawing/#2}{\pgfmathresult}}%
  \pgf@marshal%
}






% 
% 
% 
% Packing
% 
% 
% 

\pgfgddeclareforwardedkeys{/graph drawing}{
  componentwise/.graph parameter=boolean,
  componentwise/.parameter initial=false,
  componentwise/.default=true
}

\pgfgddeclareforwardedkeys{/graph drawing}{
  component sep/.graph parameter=number,
  component sep/.parameter initial=1.5em,
  component direction/.graph parameter=direction,
  component direction/.parameter initial=0,
  component align/.graph parameter=string,
  component align/.parameter initial=first node,
  align here/.node parameter=boolean,
  align here/.default=true,
  component order/.graph parameter=string,
  component packing/.graph parameter=string,
  small components first/.style={/graph drawing/component order=increasing node number},
  large components first/.style={/graph drawing/component order=decreasing node number},
  % Shortcuts
  components go right top aligned/.style={/graph drawing/component direction=0,/graph drawing/component align=counterclockwise},
  components go right absolute top aligned/.style={/graph drawing/component direction=0,/graph drawing/component align=counterclockwise bounding box},
  components go right bottom aligned/.style={/graph drawing/component direction=0,/graph drawing/component align=clockwise},
  components go right absolute bottom aligned/.style={/graph drawing/component direction=0,/graph drawing/component align=clockwise bounding box},
  components go right center aligned/.style={/graph drawing/component direction=0,/graph drawing/component align=center},
  components go right/.style={/graph drawing/component direction=0,/graph drawing/component align=first node},
  % left
  components go left top aligned/.style={/graph drawing/component direction=180,/graph drawing/component align=clockwise},
  components go left absolute top aligned/.style={/graph drawing/component direction=180,/graph drawing/component align=clockwise bounding box},
  components go left bottom aligned/.style={/graph drawing/component direction=180,/graph drawing/component align=counterclockwise},
  components go left absolute bottom aligned/.style={/graph drawing/component direction=180,/graph drawing/component align=counterclockwise bounding box},
  components go left center aligned/.style={/graph drawing/component direction=180,/graph drawing/component align=center},
  components go left/.style={/graph drawing/component direction=180,/graph drawing/component align=first node},
  % up
  components go down right aligned/.style={/graph drawing/component direction=270,/graph drawing/component align=counterclockwise},
  components go down absolute right aligned/.style={/graph drawing/component direction=270,/graph drawing/component align=counterclockwise bounding box},
  components go down left aligned/.style={/graph drawing/component direction=270,/graph drawing/component align=clockwise},
  components go down absolute left aligned/.style={/graph drawing/component direction=270,/graph drawing/component align=clockwise bounding box},
  components go down center aligned/.style={/graph drawing/component direction=270,/graph drawing/component align=center},
  components go down/.style={/graph drawing/component direction=270,/graph drawing/component align=first node},
  % down
  components go up right aligned/.style={/graph drawing/component direction=90,/graph drawing/component align=clockwise},
  components go up absolute right aligned/.style={/graph drawing/component direction=90,/graph drawing/component align=clockwise bounding box},
  components go up left aligned/.style={/graph drawing/component direction=90,/graph drawing/component align=counterclockwise},
  components go up absolute left aligned/.style={/graph drawing/component direction=90,/graph drawing/component align=counterclockwise bounding box},
  components go up center aligned/.style={/graph drawing/component direction=90,/graph drawing/component align=center},
  components go up/.style={/graph drawing/component direction=90,/graph drawing/component align=first node},
}



% 
% 
% 
% Always-present all-purpose keys
% 
% 
%


% Random seed
%
% To ensure that the same is always shown in the same way when the
% same algorithm is applied, the random is seed is reset on each call
% of the graph drawing engine. To (possibly) get different results on
% different runs, change this value.

\pgfgddeclareforwardedkeys{/graph drawing}{
  random seed/.graph parameter=number,
  random seed/.parameter initial=42
}



% General node distance.
% 
% Description:
% 
% The node distance is used as a generic term for specifying the
% desired distance between nodes in, for instance, spring layouts. For
% layered or tree layouts, the two options sibling distance and level
% distance are used instead.

\pgfgddeclareforwardedkeys{/graph drawing}{
  node distance/.graph parameter=number with optional and,
  node distance/.parameter initial=10mm,
  node pre sep/.node or graph parameter=number,
  node pre sep/.parameter initial=.333em,
  node post sep/.node or graph parameter=number,
  node post sep/.parameter initial=.333em,
  node sep/.style=,
}


% Distances between levels and siblings in layered drawings or
% tree drawings.
% 
% Description:
% 
% These keys work as in the classical typesetting of TikZ for trees. 
% Their default value is 10mm (as in tikz).

\pgfgddeclareforwardedkeys{/graph drawing}{
  level distance/.graph parameter=number,
  level distance/.parameter initial=10mm,
  level pre sep/.node or graph parameter=number,
  level pre sep/.parameter initial=.333em,
  level post sep/.node or graph parameter=number,
  level post sep/.parameter initial=.333em,
  level sep/.style=,
  sibling distance/.node or graph parameter=number,
  sibling distance/.parameter initial=10mm,
  sibling pre sep/.node or graph parameter=number,
  sibling pre sep/.parameter initial=0.333em,
  sibling post sep/.node or graph parameter=number,
  sibling post sep/.parameter initial=0.333em,
  sibling sep/.style=,
}

\pgfkeys{/graph drawing/sibling sep/.style=%
  {/graph drawing/sibling pre sep={(#1)/2},/graph drawing/sibling post sep={(#1)/2}}}
\pgfkeys{/graph drawing/level sep/.style=%
  {/graph drawing/level pre sep={(#1)/2},/graph drawing/level post sep={(#1)/2}}}
\pgfkeys{/graph drawing/node sep/.style=%
  {/graph drawing/node pre sep={(#1)/2},/graph drawing/node post sep={(#1)/2}}}



%
%
% Spanning
%
%

\pgfgddeclareforwardedkeys{/graph drawing}{
  span priority/.edge parameter=number,
  span edge/.style={/graph drawing/span priority=1},
  no span edge/.style={/graph drawing/span priority=10},
  span priority ->/.graph parameter=number,
  span priority ->/.parameter initial=3,
  span priority reversed ->/.graph parameter=number,
  span priority reversed ->/.parameter initial=9,
  span priority <-/.graph parameter=number,
  span priority <-/.parameter initial=8,
  span priority reversed <-/.graph parameter=number,
  span priority reversed <-/.parameter initial=7,
  span priority --/.graph parameter=number,
  span priority --/.parameter initial=5,
  span priority reversed --/.graph parameter=number,
  span priority reversed --/.parameter initial=5,
  span priority <->/.graph parameter=number,
  span priority <->/.parameter initial=5,
  span priority reversed <->/.graph parameter=number,
  span priority reversed <->/.parameter initial=5,
  span priority -!-/.graph parameter=number,
  span priority -!-/.parameter initial=10,
  span priority reversed -!-/.graph parameter=number,
  span priority reversed -!-/.parameter initial=10,
  span using directed/.style={
    /graph drawing/span priority reversed <-=3,
    /graph drawing/span priority <->=3,
    /graph drawing/span priority reversed <->=3,
  },
  span using all/.style={
    /graph drawing/span priority <-=5,
    /graph drawing/span priority ->=5,
    /graph drawing/span priority <->=5,
    /graph drawing/span priority --=5,
    /graph drawing/span priority -!-=5,
    /graph drawing/span priority reversed <-=5,
    /graph drawing/span priority reversed ->=5,
    /graph drawing/span priority reversed <->=5,
    /graph drawing/span priority reversed --=5,
    /graph drawing/span priority reversed -!-=5,
  }
}


% Graph events  
% 
% Although a graph consists of nodes and edges, during the
% construction of the graph a lot of information concerning the
% structure of the graph is often available. For instance, as we
% specify a graph using the child-syntax, we do not only which edges
% are present, but we can implicitly specify an ordering on the
% nodes. Even more, there is even information availble concerning
% nodes that are not present at all: A child[missing] is not present
% as a node or an edge, but a tree drawing algorithm will want to know
% about this child nevertheless.
% 
% In order to communicate such information to the graph drawing
% engine, "events" are used. As a graph is created, in addition to
% nodes and edges, "events" may happen. The events come in a
% sequential order and they are stored together with the graph. For
% each node and each edge, its index in the event sequence is
% stored, that is, it is stored how many events happened before the
% node or edge was created.
% 
% Internally, an event consists of a name and, possibly, some
% parameters. When the parameter is created on the tikz level, it will
% be a string that is passed down to Lua. Internally created events
% will also have parameters that are objects.
% 
% Two events are a bit special since they get special internal
% support: The begin and end events. The first signals that some kind
% of group has started; which is closed by the corresponding end
% event. The "kind" of group is indicated by the parameter of the
% begin event.
% 
% 
% 
% Standard events are:
% 
% For each node entered into a graph, a "node" event is automatically
% created internally with the parameter being the node. However, you
% can also create this event yourself. In this case, the parameter
% will be a string and will mean that the node is "virtual" or
% "missing", but space should be reserved for it, if possible (this is
% use, for instance, by certain tree layouts).
% 
% For each edge entered into a graph, an "edge" event is automatically
% created, with the edge as the parameter. Again, an event with a
% string parameter corresponds to a "non-existing" node.
% 
%
% Standard event groups are:
% 
%
% The "descendants" event group include a set of nodes that, at least
% inside the specification, are descendants of the last node
%
% begin descendants
% ...
% end
% 
% 
% The "array" event group collects together some nodes in an array of
% nodes. This can be used, for instance, to specify matrices.
% 
% begin array
% ...
% end 



% Create a new event
% 
% #1 = event name (should be a valid lua identifier name)
% #2 = parameter (some text)
% 
% Description:
% 
% Adds a new event to the event sequence of the graph

\def\pgfgdevent#1#2{%
  \directlua{pgf.gd.control.TeXInterface.addEvent('\luaescapestring{#1}', '\luaescapestring{#2}')}%
}


% Start an event group
% 
% #1 = kind of event group
% 
% Description:
% 
% Creates a begin event with #1 as the parameter of the begin
% event.

\def\pgfgdbegineventgroup#1{%
  \pgfgdevent{begin}{#1}%
}

% End an event group
% 
% Description:
% 
% Creates an end event.

\def\pgfgdendeventgroup{%
  \pgfgdevent{end}{}%
}


% Creates an event group for the current TeX group
%
% #1 = event group name 
%
% Description:
% 
% Issues a begin event for #1 and, using \aftergroup, adds an end
% event at the end of the current tex group.

\def\pgfgdeventgroup#1{%
  \pgfgdbegineventgroup{#1}%
  \aftergroup\pgfgdendeventgroup%
}






%
%
% Collections
%
%

% A collection is a pair consisting of a set of nodes and a set of
% edges. Since the edges need not be between the nodes of the same
% collection, collections are not subgraphs, but something more
% ``loose'' -- namely collections.
%
% Collections are grouped into ``kinds'', that is, all collections
% having the same kind will be grouped together. On the Lua layer, all
% collections of the same kind can be accessed directly via a single
% array; on the \pgfname\ layer, for each kind a separate key is available
% to indicate that a node or an edge belongs to a collection. 
%
% Collections serve two purposes: First, they can be seen as ``hints''
% to graph drawing algorithms that certain nodes and/or edges ``belong
% together''. For instance, collections of kind |same rank| are used
% by the Sugiyama algorithm to group together nodes that should appear
% at the same height of the output. Second, since collections are also
% passed back to the \pgfname\ layer in a postprocessing step, they can be
% used to render complicated concepts such as hyperedges (which are
% just collections of nodes, after all) or subgraphs.



% Declares a new collection kind
%
% #1 = kind
% #2 = layer number
%
% Description:
%
% Declares a new collection kind. This has a number of effects:
%
% First, a key |/graph drawing/|\meta{kind} gets declared and
% key forwarding is setup for this key (so you can also write
% /tikz/\meta{kind}). When this key is used inside a 
% graph drawing scope, all nodes and edges mentioned in the rest of
% the current \TeX\ scope will belong to a new collection whose kind
% is \meta{kind}. This new collection may also have some local
% options, which are specified as an argument to the key. For
% instance, suppose you write
% 
% \pgfgddeclarecollectionkind{hyper}{1}
% 
% \graph {
%   a, b, c, d;
%   { [hyper={foo=bar}] a, b, c }
%   { [hyper={red,green}] b, c, d }
% };
% 
% In this case, the nodes |a|, |b|, |c| will belong to a collection of
% kind |hyper| and this collection will have the option |foo=bar|
% set. The nodes |b|, |c|, and |d| will (also) belong to another
% collection of the same kind |hyper|, but with the options |red| and
% |green| set.
% 
% The options passed to the key are exectued with the path prefix
% |/graph drawing|. The options must all be graph parameters, node
% parameters, or edge parameters.
% 
% Normally, as claimed above, using the key will cause a new
% collection to be started inside the current \TeX\ group. However,
% this is not quite true: You can use the key |/graph drawing/name|
% inside the options passed to the key. In this case, if a collection
% of the same name has already been specified earlier (in some other
% group), the following nodes and edges get added to this earlier
% collection:
%
% \graph {
%   a, b, c, d;
%   { [hyper={name=core}] a, b }
%   { [hyper] b, c, d }
%   { [hyper={name=core}] d }
% };
% 
% In the above example, the collection |core| will be of kind |hyper|
% and will contain the nodes |a|, |b|, and |d|. A second (unnamed)
% collection of kind |hyper| will contain the nodes |b|, |c|, and
% |d|. Internally, unnamed collections get assigned a unique internal
% name.
% 
% Let us next have a look at the further effects declaring a
% collection kind has: On the Lua layer, when the graph drawing engine
% gets warmed up, the collections of the input graph get ``sorted out''
% according to their kinds. In detail, the representation of the graph
% drawing scope has a table |collections| that has an entry for each
% collection \meta{kind}. (In case \meta{kind} contains a space or
% other strange characters, you have to access the |collections| table
% through a string index. For instance, to access the |same rank|
% collections, use |collections['same rank']|.)
% 
% Each entry of the |collections| table is an array in which the
% collections of a certain kind are stored in the order they appear in
% the input. Each of these collections is itself a table, having the
% following fields: The |name| field contains the collection's name,
% either the one passed using the |name| key or the internal name
% created automatically. The |vertices| and |edges| fields each
% contain arrays of all objects being part of the collection.
%
% 
% Once a graph drawing algorithms has computed node and edge
% placements, the binding layer will attempt to ``render'' all
% collections: For this, for each collection kind, the key
% |/graph drawing/|\meta{kind}|/begin rendering| is tried once. Next, |/graph
% drawing/|\meta{kind}|/render| is tried once for each
% collection. Each time, the values stored in the |generated_options|
% table of the collection (if present) is passed to the |render|
% key. Finally, |/graph drawing/|\meta{kind}|/end rendering| is tried.
% 
% The idea of the above is that you can setup certain collection kinds
% to be rendered in a special way. Suppose, for instance, you would
% like hyperedges to be rendered. In this case, a graph drawing
% algorithm should iterate over all collections of type |hyper| and
% compute some hints on how to render the hyperedge and store this
% information in the |generated_options| table of the hyperedge. Then,
% the key |/graph drawing/hyper/render| should be setup so that it
% contains some code that is able to read key--value pairs passed to
% it (which are the key--value pairs of the |generated_options| table)
% and use this information to nicely draw the hyperedge.
% 
% The last parameter, the layer number, is used to specify the order
% in which the different collection kinds are rendered. The higher the
% number, the later the collection will be rendered. Thus, if there is
% a collection kind with layer number 10 and another with layer number
% 20, all collections of the first kind will be rendered first,
% followed by all collections of the second kind.
% 
% Collections whose layer kinds are non-negative get rendered
% \emph{after} the nodes and edges have already been rendered. In
% contrast, collections with a negative layer number get shown
% ``below'' the nodes and edges. Actually, they are also rendered
% after the nodes and edges have already been drawn, but they are a
% put in a box that is shipped out before the the box of the nodes and
% edges gets shipped out.
% 

\def\pgfgddeclarecollectionkind#1#2{
  \pgfgddeclareforwardedkeys{/graph drawing}{#1/.code=}
  \pgfgdset{#1/.append code=\pgf@gd@handle@collection{#1}{##1}}
  \directlua{pgf.gd.control.TeXInterface.addCollectionKind('\luaescapestring{#1}',#2)}
}

\def\pgf@gd@handle@collection#1#2{%
  {%
    % Reset options
    \let\pgf@gd@collection@name=\pgfutil@empty%
    \pgfkeyssetvalue{/graph drawing/graph parameters}{}%
    \pgfkeyssetvalue{/graph drawing/edge parameters}{}%
    \pgfkeyssetvalue{/graph drawing/node parameters}{}%
    \pgfgdset{#2}%
    \pgfkeysgetvalue{/graph drawing/graph parameters}\pgf@gd@gp@temp\global\let\pgf@gd@gp@temp\pgf@gd@gp@temp
    \pgfkeysgetvalue{/graph drawing/edge parameters}\pgf@gd@ep@temp\global\let\pgf@gd@ep@temp\pgf@gd@ep@temp
    \pgfkeysgetvalue{/graph drawing/node parameters}\pgf@gd@np@temp\global\let\pgf@gd@np@temp\pgf@gd@np@temp
    \global\let\pgfgdlastcollectionname\pgf@gd@collection@name
  }%
  \ifx\pgfgdlastcollectionname\pgfutil@empty%
    \edef\pgfgdlastcollectionname{collectionPGFINTERNAL\the\pgf@gd@collectioncount}%
    \global\advance\pgf@gd@collectioncount by 1\relax
  \fi%
  \pgf@gd@handle@collection@set{#1}{\pgfgdlastcollectionname}{\pgf@gd@gp@temp\pgf@gd@ep@temp\pgf@gd@np@temp}
}

\def\pgf@gd@handle@collection@set#1#2#3{%
  \edef\pgf@temp{{/graph drawing/collection memberships}{{kind='\luaescapestring{#1}',name='\luaescapestring{#2}',options={#3}}}}%
  \expandafter\pgfgdnodeparameter\pgf@temp
  \expandafter\pgfgdedgeparameter\pgf@temp
}

\pgfgdset{name/.store in=\pgf@gd@collection@name}
\pgfgdset{collection memberships/.accumulates}

\newcount\pgf@gd@collectioncount



%
% Hyperedges
%
% The hyper key can be used to group together nodes to a
% hyperedge. The hyperedges will be available to the graph drawing
% algorithm through the collections.hyper field of the scope.
% 
% Currently, there is no default renderer for hyper edges. 
%
% Example:
%
% \graph {
%   % The nodes:
%   a, b, c, d;
%  
%   % The edges:
%   {[hyper] a,b,c};
%   {[hyper] b,c,d};
%   {[hyper] a,c};
%   {[hyper] d}
% };

\pgfgddeclarecollectionkind{hyper}{1}




%
% Sublayouts
%
% Description: For a general introduction to (sub)layouts, see
% Section~\ref{section-gd-sublayouts} in the manual. 
% 
% This command starts a layout that ends at the end of the current TeX
% scope. Addtionally, when no graph drawing scope is open currently, a
% new scope is opened using
%
% A layout ends at the end of the current scope and, internally, they
% are handled mainly using collections (each sublayout is a
% collection). 
%
\pgfgddeclarecollectionkind{sublayout_collection}{0}

\newcount\pgf@gd@sublayout@stack@height
\newcount\pgf@gd@sublayout@num

\def\pgfgdbeginlayout{
  \begingroup
    \pgfgdlayoutscopeactivetrue
    % Start a collection:
    % 
    % First, compute a name
    % 
    \global\advance\pgf@gd@sublayout@num by1\relax% Note the difference with respect to \global
    \advance\pgf@gd@sublayout@stack@height by1\relax%
    % 
    \pgfgdset{sublayout_collection={name/.expanded=sublayout \the\pgf@gd@sublayout@num}} % Will create the layout collection
    \directlua{pgf.gd.control.TeXInterface.setupLayout('sublayout
      \the\pgf@gd@sublayout@num',\the\pgf@gd@sublayout@stack@height,{\pgfkeysvalueof{/graph
          drawing/graph parameters}})}%
}

\def\pgfgdendlayout{
  \endgroup%
}

\def\pgfbegininterruptlayout{
  \begingroup%
    \pgfgdlayoutscopeactivefalse%
}

\def\pgfendinterruptlayout{
  \endgroup%
}




%
% Options for subgraph nodes
% 
%
% A subgraph node is a node that "surrounds" the nodes of a
% subgraph. The special property of a subgraph node opposed to a
% normal node is that it is created only after the subgraph has been
% laid out. However, the difference to a collection like "hyper" is
% that the node is availble immediately as a normal node in the sense
% that you can connect edges to it.
% 
% What happens internally is that subgraph nodes get "registered"
% immediately both on the pgf level and on the lua level, but the
% actual node is only created inside the layout pipeline using a
% callback.
%
% The actual node creating happens when the innermost layout in which
% the subgraph node is declared has finished.
%
% 
% Because of this somewhat asynchronous call order, subgraph nodes get
% created using the special key "subgraph node". It takes three
% parameters: 
% 
% #1 = The name of the node. If this is empty, an automatic name will
% be generated.
% 
% #2 = Subgraph node text. Some text to be displayed as part of the
% node. Often, this text is not displayed for such "vast" nodes,
% but a shape may use it nevertheless (for instance, one might display
% this text at the top of the node).
% 
% #3 = Some options for the to-be-created node. (Typically, these will
% be tikz options like "draw" or "fill=blue!10,draw=blue".)
% 
%
% When the callback is called, the values of the above keys will be
% passed to the callback as follows:
% 
% subgraph point cloud = This will be a list of points (without
% separating commas) like "(10pt,20pt)(0pt,0pt)(30pt,40pt)" always in
% this syntax. The list will contain all points inside the
% subgraph. In particular, a bounding box around these points will
% encompass all nodes and bend points of the subgraph.
% The bounding box of this point cloud is guaranteed to be centered on
% the origin.
% 
% subgraph bounding box width = This will be the width of a bounding box
% (in points with the "pt" suffix).
% 
% subgraph bounding box height = This will be the height of a bounding box
% (in points with the "pt" suffix).
% 
% subgraph text = This will be text originally given to the subgraph node
% text option.
% 
% The name of the node is passed using the name key.
% 
% The subgraph options will be passed as options to the callback.
%
% 
% Note that the "text" given to the \node or \pgfnode command inside
% the callback will be a call to \pgfgdsubgraphnodecontents. This
% command expands to a box of height "subgraph bounding box height" and
% width "subgraph bounding box width", but feel free to redefine as a
% side-effect of "every subgraph node".
% 
% 
% Example:
% 
% Suppose you say
% 
% \tikzset{subgraph node={vast node}{Vast Node 1}{draw, thick}}
% 
% Then, during the run of the graph drawing engine, at some point the
% following command will be called, assuming that the nodes inside the
% subgraph node occupy an area with a bounding box of 40pt by 20pt:
% 
% \node [name=vast node,
%        /graph drawing/.cd,
%        subgraph point cloud={(-20pt,-10pt)(20pt,10pt)},
%        subgraph bounding box width=40pt,
%        subgraph bounding box height=20pt,
%        subgraph text={Vast Node 1},
%        start subgraph node,
%        draw, thick] {\pgfgdsubgraphnodecontents};

\pgfgddeclarecollectionkind{subgraph node collection}{0}

\pgfgddeclareforwardedkeys{/graph drawing}{%
  subgraph node/.code n args={3}{},
  subgraph node text/.node parameter=string,
  subgraph node options/.node parameter=string,
}

\pgfgdset{/graph drawing/subgraph node/.code n args={3}{%
    \pgfgdset{
      subgraph node collection={%
        name/.expanded={#1}
      }
    }
    \begingroup% build protections inside which we can execute options
      \setbox0=\hbox{{%
          \pgfinterruptpath%
          \pgfgdset{.unknown/.code=,
            subgraph node text={#2},
            subgraph node options={#3},
            #3}%
            \directlua{pgf.gd.control.TeXInterface.registerSubgraphNode('\pgfgdlastcollectionname', %
              \the\pgf@gd@sublayout@stack@height,%
              {\pgfkeysvalueof{/graph drawing/node parameters}})}
            \expandafter\pgffakenode\expandafter{\pgfgdlastcollectionname}
          \endpgfinterruptpath%
        }}%
    \endgroup%
  }
}

\pgfgdset{
  subgraph point cloud/.initial=,
  subgraph bounding box width/.initial=,
  subgraph bounding box height/.initial=,
  subgraph text/.initial=,
  start subgraph node/.style=
}

\def\pgfgdsubgraphnodecontents{%
  \hbox to \pgfkeysvalueof{/graph drawing/subgraph bounding box width}{%
    \vrule width0pt height\pgfkeysvalueof{/graph drawing/subgraph bounding box height}\hfil}%
}


%
% Callback method for \pgf@gd@positionnodelater
% 
% Pipes the box which contains the nodes to lua.
% The called lua method then saves the data.
%
\def\pgf@gd@positionnode@callback{%
  {%
    % save options to macro \pgf@gd@node@options
    \pgfkeysgetvalue{/graph drawing/node parameters}\pgf@gd@node@options
    % evaluate coordinates
    \pgfmathsetmacro{\pgf@gd@node@minx}{\pgfpositionnodelaterminx}%
    \pgfmathsetmacro{\pgf@gd@node@miny}{\pgfpositionnodelaterminy}%
    \pgfmathsetmacro{\pgf@gd@node@maxx}{\pgfpositionnodelatermaxx}%
    \pgfmathsetmacro{\pgf@gd@node@maxy}{\pgfpositionnodelatermaxy}%
    % call lua system library to create a lua node object
    \directlua{
      pgf.gd.control.TeXInterface.addPgfNode(
        \pgfpositionnodelaterbox,
        '\luaescapestring{\pgfpositionnodelatername}',
        '\luaescapestring{\csname pgf@sh@ns@\pgfpositionnodelatername\endcsname}',
        \pgf@gd@node@minx,
        \pgf@gd@node@miny,
        \pgf@gd@node@maxx,
        \pgf@gd@node@maxy,
        {\pgf@gd@node@options}) }
  }%
}

%
% Shipout a node callback
% 
% #1 = name of the node
% #2 = x min of the bounding box
% #3 = x max of the bounding box
% #4 = y min of the bounding box
% #5 = y max of the bounding box
% #6 = desired x pos of the node
% #7 = desired y pos of the node
% #8 = box register number of the TeX node
% #9 = the late setup options
%
% This callback will be called by the engine for every original node
% when it finally needs to placed at a final position.

\def\pgfgdshipoutnodecallback#1#2#3#4#5#6#7#8{%
  {%
    \def\pgfpositionnodelatername{#1}
    \def\pgfpositionnodelaterminx{#2}
    \def\pgfpositionnodelatermaxx{#3}
    \def\pgfpositionnodelaterminy{#4}
    \def\pgfpositionnodelatermaxy{#5}
    \directlua{
      texnode = pgf.gd.control.TeXInterface.retrieveBox(#8)
      tex.box[\pgfpositionnodelaterbox] = texnode
    }
    \pgfpositionnodenow{\pgfqpoint{#6pt}{#7pt}}
  }%
}



% Generate a node 
%
% This callback is called from the engine whenever an algorithm
% generates a new node internally.
%
% #1 = name of the node
% #2 = shape of the node
% #3 = options generated by the algorithm in key-value syntax. The set
% of generated options is algorithm-dependent.
% #4 = text
%
% This is an internal function and will be called by the Lua engine

\def\pgfgdgeneratenodecallback#1#2#3#4{%
  {
    \pgfkeys{#3}
    \pgfnode{#2}{\pgfkeysvalueof{/graph drawing/generated
        node/anchor}}{#4}{#1}{\pgfkeysvalueof{/graph drawing/generated
        node/use path}} 
  }
}

\pgfkeys{
  /graph drawing/generated node/anchor/.initial=center,
  /graph drawing/generated node/use path/.initial=\pgfusepath{}
}